## 🔗 [Understanding SSR with Hydration: Pros, Cons, and Scenarios for Software Architects](https://www.workingsoftware.dev/understanding-ssr-with-hydration-for-software-architects/?utm_source=newsletter.reactdigest.net&utm_medium=newsletter&utm_campaign=understanding-ssr-with-hydration)

### 🗓️ 번역 날짜: 2024.07.22

### 🧚 번역한 크루: 러기(박정우)

---

## 하이드레이션을 통한 SSR 이해하기: 장단점 및 소프트웨어 아키텍트를 위한 시나리오

현재 다양한 프론트엔드 렌더링 및 하이드레이션 기법을 실험하고 있습니다. Angular(JS)와 React를 사용한 클라이언트 사이드 렌더링(CSR)이 최근 트렌드였지만, SSR이 다시 부상하고 있습니다.

이 블로그 포스트를 통해 클라이언트 사이드 하이드레이션을 포함한 SSR에 대해 알아보겠습니다.

프론트엔드 아키텍처에 대한 이전 블로그 포스트도 참고해 보세요 👇

[Which web frontend architecture fits best?](https://www.workingsoftware.dev/frontend-rendering-techniques/)

## 핵심 용어 설명

시작하기 전에 몇 가지 중요한 용어를 명확히 해보겠습니다:

- 렌더링(Rendering): 템플릿과 데이터를 결합하여 웹 콘텐츠를 생성하는 것.
- 하이드레이션(Hydration): 서버에서 렌더링된 HTML에 클라이언트 측 상호작용 기능을 추가하는 것.

## 프론트엔드에서 "렌더링"이란 무엇인가요?

![What is Rendering](https://www.workingsoftware.dev/content/images/size/w1600/2024/07/1.png)

프론트엔드 개발에서 "렌더링"이란 템플릿(마크업)과 데이터를 결합하여 웹 페이지나 웹 앱 뷰의 콘텐츠를 생성하는 과정을 의미합니다. 이 중요한 단계는 사용자가 브라우저에서 보게 될 시각적 표현을 만들어냅니다.

프론트엔드에서 "하이드레이션"이란?
"하이드레이션"은 서버 사이드 렌더링(SSR)과 관련된 기술로, 서버에서 렌더링된 HTML 문서를 클라이언트 측에서 완전히 상호작용 가능한 웹 애플리케이션으로 변환하는 과정을 말합니다.

![What is Hydration](https://www.workingsoftware.dev/content/images/size/w1600/2024/07/2-1.png)

초기 서버 사이드 렌더링된 HTML 파일은 아직 상호작용이 불가능합니다. 이벤트 리스너를 연결하고, 상태를 초기화하며, 페이지를 동적으로 만들기 위해 JavaScript 코드가 실행되어야 합니다. 이 정적인 HTML에 상호작용을 추가하는 과정을 "하이드레이션"이라고 합니다.

## 하이드레이션을 통한 SSR 아키텍처 개요

이제 프론트엔드 아키텍처에서 하이드레이션을 통한 SSR(서버 사이드 렌더링)의 아키텍처 개요를 살펴보겠습니다. 이 접근 방식은 종종 아이소모픽(isomorphic)이라고 불리는데, 이는 코드베이스가 서버와 클라이언트 모두에서 실행될 수 있기 때문입니다.

![SSR with Hydration](https://www.workingsoftware.dev/content/images/size/w1600/2024/07/3-2.png)

이 아키텍처에서 초기 렌더링은 주로 Node.js 또는 유사한 런타임을 사용하여 서버에서 수행됩니다. 작동 방식은 다음과 같습니다:

1. 클라이언트(브라우저)가 웹 앱을 요청합니다.
2. 이 요청은 서버가 뷰의 초기 렌더링을 수행하게 합니다. 이 과정에서 서버는 데이터를 가져올 수도 있습니다. 서버에서 React를 사용하여 문자열로 렌더링하는 방법은 다음과 같습니다:

   ```jsx
   const html = renderToString(<App />);
   ```

3. 서버는 초기 렌더링된 정적 뷰와 함께 JavaScript 번들(일반적으로 싱글 페이지 애플리케이션 프레임워크) 및 스타일링 자산을 클라이언트에 반환합니다.
4. 클라이언트(브라우저)는 정적 HTML을 읽고 JavaScript 번들을 로드합니다.
5. JavaScript 번들이 로드되면, 브라우저는 클라이언트 측에서 웹 앱을 '하이드레이트'할 수 있습니다. 하이드레이션은 기존 DOM 요소에 이벤트 핸들러를 연결하고 애플리케이션 상태를 복원하는 과정을 포함합니다.

   하이드레이션의 예는 다음과 같습니다:

   ```jsx
   import { hydrateRoot } from "react-dom/client";
   import { BrowserRouter } from "react-router-dom";
   import App from "./App";

   const domNode = document.getElementById("root");

   hydrateRoot(
     domNode,
     <BrowserRouter>
       <App />
     </BrowserRouter>
   );
   ```

이 과정을 통해 정적 HTML은 싱글 페이지 애플리케이션(SPA)으로 변환됩니다. 이는 DOM 구조가 재사용되고, 이벤트 핸들러가 DOM 요소에 연결되며, 애플리케이션 상태가 클라이언트에서 복원됨을 의미합니다. 웹 앱은 SPA로 동작할 수 있게 됩니다.

옵션으로, SPA는 추가 HTTP 요청을 수행하고 클라이언트 측에서 결과를 렌더링할 수 있습니다.

## SSR과 하이드레이션이 이상적인 시나리오

💡 **SEO 최적화**: 초기 콘텐츠가 검색 엔진에 의해 쉽게 크롤링되고 인덱싱되어 가시성과 검색 순위를 향상시킵니다.

💡 **빠른 초기 로드**: 서버 사이드 렌더링은 클라이언트에 완전히 형성된 HTML 문서를 제공하여 더 빠른 인지 로드 시간을 제공합니다.

💡 **향상된 사용자 경험**: 하이드레이션은 풍부한 상호작용과 동적 콘텐츠 업데이트를 가능하게 하여 매끄럽고 몰입감 있는 사용자 경험을 제공합니다.

💡 **성능 개선**: 초기 렌더링을 서버로 오프로드하여 제한된 리소스를 가진 클라이언트 디바이스가 애플리케이션을 더 효율적으로 처리할 수 있게 합니다. 하이드레이션은 DOM 노드를 재생성하는 추가 작업을 피함으로써 애플리케이션 성능을 향상시킵니다.

하이드레이션이 활성화되지 않으면 서버 사이드 렌더링된 Angular 애플리케이션은 애플리케이션의 DOM을 파괴하고 다시 렌더링하여 UI 깜빡임을 유발할 수 있습니다. 이 재렌더링은 LCP(가장 큰 콘텐츠가 표시되는 시간)와 같은 핵심 웹 성능 지표(Core Web Vitals)에 부정적인 영향을 미치고 레이아웃 이동을 유발할 수 있습니다. 하이드레이션을 활성화하면 기존 DOM을 재사용하여 깜빡임을 방지할 수 있습니다.

### 하이드레이션이 이상적인 시나리오

- **전자상거래 웹 앱**
  - **상품 페이지**: 검색 엔진에 의해 인덱싱되어 가시성을 높이고, 빠르게 로드되어 사용자 주목을 끌어야 합니다. SSR은 서버 측에서 상품 정보를 렌더링하고, 하이드레이션은 장바구니에 추가, 상품 확대, 리뷰 등 동적 기능을 활성화합니다.
  - **카테고리 페이지**: 카테고리 또는 목록은 빠른 로드와 SEO를 위해 SSR을 활용하고, 하이드레이션은 페이지 전체를 새로 고침하지 않고 정렬, 필터링 및 페이지 매김을 가능하게 합니다.
- **소셜 미디어 플랫폼**
  - **사용자 피드**: 소셜 미디어 피드는 빠른 초기 로드와 공개 콘텐츠의 SEO를 위해 SSR을 활용하고, 하이드레이션은 실시간 업데이트, 상호작용 요소(좋아요, 댓글, 공유) 및 무한 스크롤을 가능하게 합니다.
  - **프로필 페이지**: SSR은 사용자 프로필과 게시물을 먼저 렌더링하여 SEO와 빠른 로드 시간을 제공하고, 하이드레이션은 동적 콘텐츠 업데이트와 상호작용을 가능하게 합니다.
- **콘텐츠 관리 시스템(CMS)**
  - **블로그 게시물 및 페이지**: SSR은 블로그 게시물을 서버 측에서 렌더링하여 빠른 로드 시간과 SEO를 제공하고, 하이드레이션은 댓글, 좋아요 및 콘텐츠 편집과 같은 동적 기능을 지원합니다.
  - **랜딩 페이지**: 마케팅 및 정보 랜딩 페이지는 빠른 로드 시간과 SEO를 위해 SSR을 활용하고, 하이드레이션은 양식, 애니메이션 및 동적 콘텐츠 업데이트와 같은 상호작용 요소를 가능하게 합니다.
- **사용자 대시보드 및 포털**
  - **개인화된 대시보드**: SSR은 서버 측에서 기본 레이아웃과 정적 데이터를 렌더링하여 빠르게 로드하고, 하이드레이션은 동적 데이터 검색, 실시간 업데이트 및 인터랙티브 위젯을 처리합니다.
  - **인트라넷 및 기업 포털**: SSR은 공용 영역의 빠른 로드 시간과 SEO를 보장하고, 하이드레이션은 내부 메시징, 알림 및 데이터 기반 애플리케이션과 같은 상호작용 기능을 가능하게 합니다.
- **프로그레시브 웹 애플리케이션(PWAs)**
  - **오프라인 우선 애플리케이션**: SSR은 빠른 로드 시간을 보장하기 위해 서버 우선 콘텐츠를 렌더링하고, 하이드레이션은 오프라인 기능, 캐싱 및 백그라운드 갱신을 관리합니다.
  - **실시간 데이터 애플리케이션**: SSR은 초기 애플리케이션 상태 렌더링을 처리하고, 하이드레이션은 실시간 데이터 업데이트, 사용자 상호작용 및 동적 콘텐츠 로드를 관리합니다.
- **복잡한 양식 및 다단계 프로세스**
  - **등록 및 결제 흐름**: SSR은 서버 측에서 초기 양식이나 단계를 렌더링하여 로드 시간을 줄이고, 하이드레이션은 검증, 동적 필드 업데이트 및 페이지 전체를 새로 고침 없이 단계 간의 원활한 전환을 가능하게 합니다.
  - **인터랙티브 설문조사**: SSR은 서버 측에서 초기 설문조사 레이아웃을 렌더링하고, 하이드레이션은 동적 질문 로드, 사용자 입력 검증 및 진행 상황 추적을 관리합니다.

## SSR with Hydration이 유용하지 않은 시나리오

❗하이드레이션의 단점:

- **복잡성 증가**: SSR과 하이드레이션은 상태 관리, 서버와 클라이언트 간의 동기화, 엣지 케이스 처리 등에서 추가적인 복잡성을 초래합니다. 이는 개발 및 유지보수 비용 증가로 이어질 수 있습니다.
- **추가적인 성능 오버헤드**: 서버에서 렌더링된 HTML을 하이드레이트하는 과정은 성능 저하를 초래할 수 있으며, 특히 느린 네트워크나 성능이 낮은 디바이스에서 더욱 그렇습니다. 이는 SSR의 초기 로드 시간 이점을 상쇄할 수 있습니다.
- **복잡한 개발 및 디버깅**: 서버에서 렌더링된 HTML과 클라이언트 측 JavaScript 간의 불일치로 인한 문제를 해결하는 것이 어렵습니다. 개발자는 서버 측과 클라이언트 측 기술에 모두 능숙해야 하며, 이는 학습 곡선과 오류의 위험을 증가시킵니다.
- **자원 관리**: 각 요청에 대해 HTML을 렌더링할 수 있는 견고한 인프라가 필요합니다.

SSR과 하이드레이션이 유용하지 않은 경우:

### 고도로 상호작용적인 싱글 페이지 애플리케이션(SPA):

- **실시간 협업 도구**: 협업 편집 도구(Google Docs 등)와 같은 애플리케이션은 실시간 업데이트와 강력한 클라이언트 측 상호작용이 자주 필요합니다. 데이터 실시간 동기화와 사용자 상호작용을 수행할 때 SSR의 오버헤드 없이 CSR이 더 효율적일 수 있습니다.
- **게임 및 그래픽 애플리케이션**: 온라인 게임이나 WebGL 또는 기타 클라이언트 측 그래픽 라이브러리에 크게 의존하는 애플리케이션은 CSR에 더 적합합니다. 게임 플레이 중 요구되는 지속적인 상호작용과 성능에 비해 SSR의 초기 로드 이점은 덜 중요합니다.

### 정적 콘텐츠가 있는 웹사이트:

- **정적 블로그 및 문서 사이트**: 자주 변경되지 않는 콘텐츠의 경우, 정적 사이트 생성(SSG)이 더 효율적입니다. SSG는 빌드 과정에서 정적 HTML 파일을 생성하여 사용자가 직접 제공받을 수 있게 하여 각 요청에 대한 서버 사이드 렌더링 및 하이드레이션을 제거합니다.
- **마케팅 랜딩 페이지**: 주로 정적 콘텐츠로 구성되고 자주 업데이트할 필요가 없는 페이지는 SSG의 이점을 누릴 수 있습니다. 이는 빠른 로드 시간, 우수한 SEO 및 SSR과 하이드레이션의 복잡성을 줄입니다.

### 동적 상호작용이 없는 간단한 웹사이트:

- **단순 기업 웹사이트**: 회사 프로필, 연락처 정보 및 서비스 설명과 같은 정적 정보를 표시하는 단순한 기업 웹사이트는 SSG 또는 단순 정적 HTML/CSS를 사용하여 SSR과 하이드레이션의 복잡성을 피할 수 있습니다.
- **포트폴리오 웹사이트**: 정적 콘텐츠, 이미지 및 프로젝트 설명을 표시하는 개인 또는 전문 포트폴리오는 SSG를 사용하여 빠른 로드 시간과 단순성을 제공합니다.

### 자원이 제한된 환경:

- **낮은 대역폭의 네트워크**: 느린 인터넷 연결 환경에서는 하이드레이션에 필요한 추가 JavaScript가 병목 현상이 될 수 있습니다. 최소한의 JavaScript를 사용하는 SSG가 더 나은 접근 방식일 수 있습니다.
- **성능이 낮은 디바이스**: CPU 및 메모리 용량이 제한된 디바이스는 하이드레이션의 오버헤드에 어려움을 겪을 수 있습니다. 최적화된 경량 프레임워크를 사용하는 SSG 또는 CSR이 더 나은 사용자 경험을 제공할 수 있습니다.

### SEO 요구사항이 최소인 애플리케이션:

- **내부 도구 및 대시보드**: SEO가 문제가 되지 않는 내부 사용 애플리케이션은 더 빠른 개발 주기와 간단한 아키텍처를 위해 CSR을 사용할 수 있습니다. 내부 대시보드 및 도구의 경우, 초기 로드 시간과 SEO보다 클라이언트 측 성능과 상호작용이 우선시됩니다.
- **인증된 사용자만 접근 가능한 플랫폼**: 모든 또는 대부분의 콘텐츠가 인증 뒤에 있는 플랫폼(SaaS 애플리케이션 등)은 SEO가 중요하지 않으므로 CSR이 더 유리하며, 초기 서버 사이드 렌더링이 불필요하게 복잡할 수 있습니다.

### 빠른 개발 주기와 단순성:

- **프로토타이핑 및 MVP**: 프로토타입 단계나 최소 기능 제품(MVP)에서는 CSR의 단순성과 속도가 개발을 가속화할 수 있습니다. SSR과 하이드레이션의 도입은 초기 단계에서 필요하지 않을 수 있는 복잡성을 추가합니다.
- **소규모 개발팀**: 자원과 전문 지식이 제한된 팀은 CSR, SSR 또는 SSG를 사용하여 SSR과 하이드레이션의 추가 복잡성과 유지보수를 피할 수 있습니다.

### 예제 애플리케이션

SSR이 하이드레이션과 함께 어떻게 작동하는지 보여주기 위해, React와 expressjs를 사용한 작은 샘플 프로젝트를 만들었습니다 👇

[GitHub - bitsmuggler/react-simple-ssr-hydration-example at workingsoftware.dev](https://github.com/bitsmuggler/react-simple-ssr-hydration-example?ref=workingsoftware.dev)
