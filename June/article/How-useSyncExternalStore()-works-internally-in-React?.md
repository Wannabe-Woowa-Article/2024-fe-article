## üîó [How useSyncExternalStore() works internally in React?](https://jser.dev/2023-08-02-usesyncexternalstore/)

### üóìÔ∏è Î≤àÏó≠ ÎÇ†Ïßú: 2024.06.10

### üßö Î≤àÏó≠Ìïú ÌÅ¨Î£®: Î≤ÑÍ±¥Îîî(Ï†ÑÌÉúÌóå)

---

# Î¶¨Ïï°Ìä∏ÏóêÏÑú useSyncExternalStoreÎäî ÎÇ¥Î∂ÄÏ†ÅÏúºÎ°ú Ïñ¥ÎñªÍ≤å ÎèôÏûëÌïòÎäîÍ∞Ä ?

`useSyncExternalStore()`Îäî Ïô∏Î∂Ä Ï†ÄÏû•ÏÜåÏóê Íµ¨ÎèÖÌï† Ïàò ÏûàÍ≤å Ìï¥Ï£ºÎäî React ÌõÖÏûÖÎãàÎã§.

Ï†ÄÎäî Ïù¥ ÌõÖÏùÑ ÏÇ¨Ïö©Ìï¥Î≥∏ Ï†ÅÏù¥ ÏóÜÏßÄÎßå, Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏôÄ Í∞ôÏùÄ ÏûêÏ≤¥ ÏÉÅÌÉúÎ•º Í∞ÄÏßÑ Ïõπ APIÏôÄ ÏÉÅÌò∏ÏûëÏö©ÌïòÎäî Í≤ÉÏù¥ ÏùºÎ∞òÏ†ÅÏù¥Í∏∞ ÎïåÎ¨∏Ïóê ÍΩ§ Ïú†Ïö©Ìï† Í≤É Í∞ôÏäµÎãàÎã§.

## 1. Ïôú useSyncExternalStoreÎäî ÌïÑÏöîÌïúÍ∞Ä ?

ÏïÑÎûòÎäî React.devÏóêÏÑú Í∞ÄÏ†∏Ïò® [Îç∞Î™® ÏΩîÎìú](https://react.dev/reference/react/useSyncExternalStore)ÏûÖÎãàÎã§.

Ïù¥ ÏΩîÎìúÎäî Î∏åÎùºÏö∞Ï†ÄÏùò ÌòÑÏû¨ Ïò®ÎùºÏù∏ ÏÉÅÌÉúÎ•º Î≥¥Ïó¨Ï§çÎãàÎã§.

ÎÑ§Ìä∏ÏõåÌÅ¨Î•º ÎÅÑÎ©¥ ÏÉÅÌÉúÍ∞Ä Í∑∏Ïóê Îî∞Îùº ÏóÖÎç∞Ïù¥Ìä∏ÎêòÎäî Í≤ÉÏùÑ Î≥º Ïàò ÏûàÏäµÎãàÎã§.

ÏùºÎ∂Ä ÏΩîÎìúÎäî ÏàòÏ†ïÎêòÏóàÏäµÎãàÎã§.

## - useOnlineStatus.js

```jsx
import { useEffect, useCallback, useState } from "react";

export function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);

  const update = useCallback(() => {
    setIsOnline(navigator.onLine);
  }, []);

  useEffect(() => {
    window.addEventListener("online", update);
    window.addEventListener("offline", update);
    return () => {
      window.removeEventListener("online", update);
      window.removeEventListener("offline", update);
    };
  }, [update]);

  return isOnline;
}
```

## - App.js

```jsx
import { useOnlineStatus } from "./useOnlineStatus.js";

function StatusBar() {
  const isOnline = useOnlineStatus();
  return <h1>{isOnline ? "‚úÖ Online" : "‚ùå Disconnected"}</h1>;
}

function SaveButton() {
  const isOnline = useOnlineStatus();

  function handleSaveClick() {
    console.log("‚úÖ Progress saved");
  }

  return (
    <button disabled={!isOnline} onClick={handleSaveClick}>
      {isOnline ? "Save progress" : "Reconnecting..."}
    </button>
  );
}

export default function App() {
  return (
    <>
      <p>Turn on & off your network to see the status changing</p>
      <StatusBar />
    </>
  );
}
```

Ï†ÄÎßåÏùò `useOnlineStatus`Î•º ÏïÑÎûòÏôÄ Í∞ôÏù¥ ÎßåÎì§ÏóàÏäµÎãàÎã§.

```jsx
import { useEffect, useCallback, useState } from "react";
export function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  const update = useCallback(() => {
    setIsOnline(navigator.onLine);
  }, []);
  useEffect(() => {
    window.addEventListener("online", update);
    window.addEventListener("offline", update);
    return () => {
      window.removeEventListener("online", update);
      window.removeEventListener("offline", update);
    };
  }, [update]);
  return isOnline;
}
```

ÏΩîÎìúÎäî Í¥úÏ∞ÆÏïÑ Î≥¥Ïù¥ÏßÄÎßå Ïã§Ï†úÎ°úÎäî Í≤¨Í≥†ÌïòÏßÄ ÏïäÏäµÎãàÎã§.

ÌïµÏã¨ Î¨∏Ï†úÎäî Ïô∏Î∂Ä Ï†ÄÏû•ÏÜåÍ∞Ä Ïñ∏Ï†úÎì†ÏßÄ ÏóÖÎç∞Ïù¥Ìä∏Îê† Ïàò ÏûàÎã§Îäî Ï†êÏûÖÎãàÎã§.

Îî∞ÎùºÏÑú `useState()`ÏôÄ `useEffect()` ÏÇ¨Ïù¥Ïóê Î≥ÄÍ≤ΩÎê† Ïàò ÏûàÏúºÎ©∞, Ïù¥ Í≤ΩÏö∞ Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨Í∞Ä ÎÇòÏ§ëÏóê Îì±Î°ùÎêòÎØÄÎ°ú Î≥ÄÍ≤Ω ÏÇ¨Ìï≠ÏùÑ Í∞êÏßÄÌï† Ïàò ÏóÜÏäµÎãàÎã§.

Ï¢Ä Îçî ÏùºÏ∞ç Ïã§ÌñâÎêòÎäî `useLayoutEffect()`ÎÇò `useInsertionEffect()`Î°ú Ï†ÑÌôòÌï¥ÎèÑ Î¨∏Ï†úÎäî Ìï¥Í≤∞ÎêòÏßÄ ÏïäÏäµÎãàÎã§.

Ïô∏Î∂Ä Ï†ÄÏû•ÏÜåÏóê ÎåÄÌï¥ ÏïÑÎ¨¥Í≤ÉÎèÑ Ïïå Ïàò ÏóÜÍ∏∞ ÎïåÎ¨∏ÏûÖÎãàÎã§.

Ïù¥ Î¨∏Ï†úÎ•º Ìï¥Í≤∞ÌïòÎ†§Î©¥ **Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨Í∞Ä Ïô∏Î∂Ä Ï†ÄÏû•ÏÜåÎ•º Ï≤òÏùå Í∞ÄÏ†∏Ïò¨ ÎïåÎ≥¥Îã§ Îä¶ÏßÄ ÏïäÍ≤å Îì±Î°ùÎêòÎèÑÎ°ù ÌïòÍ±∞ÎÇò**, Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨Í∞Ä Îì±Î°ùÎêú ÌõÑ Ìïú Î≤à Îçî ÌôïÏù∏Ìï¥Ïïº Ìï©ÎãàÎã§.

ÏïÑÎûòÏôÄ Í∞ôÏù¥ Ìï† Ïàò ÏûàÏäµÎãàÎã§.

```ts
import { useEffect, useCallback, useState } from "react";
export function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  const update = useCallback(() => {
    setIsOnline(navigator.onLine);
  }, []);
  useEffect(() => {
    window.addEventListener("online", update);
    window.addEventListener("offline", update);
    update();
    // Ïô∏Î∂Ä Ï†ÄÏû•ÏÜåÍ∞Ä Î≥ÄÍ≤ΩÎê† Ïàò ÏûàÏúºÎØÄÎ°ú Ìïú Î≤à Îçî ÌôïÏù∏ÌïòÎäî Î∞©Î≤ïÏùÄ Îã§ÏùåÍ≥º Í∞ôÏäµÎãàÎã§.

    return () => {
      window.removeEventListener("online", update);
      window.removeEventListener("offline", update);
    };
  }, [update]);
  return isOnline;
}
```

Ï§ëÎ≥µÎêú ÏΩîÎìúÎ•º ÏßÄÏõÄÏúºÎ°úÏç® Ï°∞Í∏à Îçî ÎÇ´ÎèÑÎ°ù ÏàòÏ†ïÌï¥Î≥¥Í≤†ÏäµÎãàÎã§.

```ts
import { useEffect, useCallback, useState } from "react";
function getIsOnLine() {
  return navigator.onLine;
}
function subscribe(callback) {
  window.addEventListener("online", callback);
  window.addEventListener("offline", callback);
  callback();
  // Ïù¥Îäî ÏµúÏã† Îç∞Ïù¥ÌÑ∞Î•º Í≤ÄÏÉâÌïòÎäî Îç∞ Ï§ëÏöîÌï©ÎãàÎã§.

  return () => {
    window.removeEventListener("online", callback);
    window.removeEventListener("offline", callback);
  };
}
export function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(getIsOnLine());
  const update = useCallback(() => {
    setIsOnline(getIsOnLine());
  }, []);
  useEffect(() => {
    return subscribe(update);
  }, [update]);
  return isOnline;
}
```

Ïö∞Î¶¨Îäî Ïù¥Í≤ÉÏùÑ `useSyncExternalStore()`Ï≤òÎüº Îçî ÎπÑÏä∑ÌïòÍ≤å ÎßåÎì§ Ïàò ÏûàÏäµÎãàÎã§.

```tsx
import { useEffect, useCallback, useState } from "react";

function getIsOnLine() {
  return navigator.onLine;
}

function subscribe(callback) {
  window.addEventListener("online", callback);
  window.addEventListener("offline", callback);
  return () => {
    window.removeEventListener("online", callback);
    window.removeEventListener("offline", callback);
  };
}
function useSyncExternalStore(subscribe, getSnapshot) {
  const [data, setData] = useState(getSnapshot());
  const update = useCallback(() => {
    setData(getSnapshot());
  }, []);
  useEffect(() => {
    update();
    return subscribe(update);
  }, [update]);
  return data;
}

export function useOnlineStatus() {
  const isOnline = useSyncExternalStore(subscribe, getIsOnLine);
  return isOnline;
}
```

## - App.js

```tsx
import { useOnlineStatus } from "./useOnlineStatus.js";

function StatusBar() {
  const isOnline = useOnlineStatus();
  return <h1>{isOnline ? "‚úÖ Online" : "‚ùå Disconnected"}</h1>;
}

export default function App() {
  return (
    <>
      <p>Turn on & off your network to see the status changing</p>
      <StatusBar />
    </>
  );
}
```

Ïö∞Î¶¨Í∞Ä Ïô∏Î∂Ä Ï†ÄÏû•ÏÜåÎ•º ÎèôÍ∏∞ÌôîÌï† Îïå Ïñ¥Î†§Ïö¥ Î∂ÄÎ∂ÑÏùÄ Ïô∏Î∂ÄÏùò Î™®Îì† ÏóÖÎç∞Ïù¥Ìä∏Í∞Ä Í∞êÏßÄÎêòÎèÑÎ°ù ÌïòÎäî Í≤ÉÏûÖÎãàÎã§.

Ïö∞Î¶¨Ïùò Ìï¥Í≤∞Ï±ÖÏùÄ **Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑàÍ∞Ä Îì±Î°ùÎêú ÌõÑ ÏóÖÎç∞Ïù¥Ìä∏Í∞Ä Î∞úÏÉùÌïòÎèÑÎ°ù Î≥¥Ïû•ÌïòÎäî Í≤É**ÏûÖÎãàÎã§.

ÌïòÏßÄÎßå Ïó¨Ï†ÑÌûà Ïö∞Î¶¨Ïùò Íµ¨ÌòÑÏóêÎäî Î¨∏Ï†úÍ∞Ä ÏûàÏäµÎãàÎã§. Î∞îÎ°ú 'Ï∞¢ÍπÄ(tear)' ÌòÑÏÉÅÏûÖÎãàÎã§.

## - Ï∞¢ÍπÄ(Tearing) Î¨∏Ï†ú

Î¶¨Ïï°Ìä∏ ÌåÄÏù¥ [Ï∞¢ÍπÄ(tearing)](https://github.com/reactwg/react-18/discussions/69) ÌòÑÏÉÅÏóê ÎåÄÌï¥ ÌõåÎ•≠ÌïòÍ≤å ÏÑ§Î™ÖÌï¥Ï£ºÏóàÎäîÎç∞, Ïó¨Í∏∞ÏÑúÎäî Í∞ÑÎã®Ìûà ÏöîÏïΩÌï¥Î≥¥Í≤†ÏäµÎãàÎã§.

Î¶¨Ïï°Ìä∏ ÌåÄÏóêÏÑú [useTransition()Ïù¥ ÎÇ¥Î∂ÄÏ†ÅÏúºÎ°ú Ïñ¥ÎñªÍ≤å ÏûëÎèôÌïòÎäîÏßÄ ÏÑ§Î™Ö](https://jser.dev/2023-05-19-how-does-usetransition-work/)Ìï† Îïå Ïñ∏Í∏âÌñàÎìØÏù¥, ÎèôÏãú Î™®Îìú(concurrent mode)ÏóêÏÑúÎäî Î†åÎçîÎßÅ Îã®Í≥ÑÍ∞Ä ÏûëÏóÖÏùò Ïö∞ÏÑ†ÏàúÏúÑÏóê Îî∞Îùº Ï§ëÎã®ÎêòÍ≥† Ïû¨Í∞úÎê† Ïàò ÏûàÏäµÎãàÎã§.

Í∑∏ÎûòÏÑú Î¶¨Ïï°Ìä∏Í∞Ä React Ìä∏Î¶¨Î•º Î†åÎçîÎßÅÌïòÎäî ÎèôÏïà, Ïù¥ Í≥ºÏ†ïÏù¥ Ï§ëÎã®ÎêòÍ≥† ÎπÑÎèôÍ∏∞ Ïä§ÏºÄÏ§ÑÎßÅÏúºÎ°ú Ïó¨Îü¨ Î≤à ÏãúÎèÑÎê† Í∞ÄÎä•ÏÑ±Ïù¥ ÏûàÏäµÎãàÎã§.

Ïù¥ Ïä§ÏºÄÏ§ÑÎßÅÏù¥ ÎèôÍ∏∞Ï†ÅÏù¥ÏßÄ ÏïäÍ∏∞ ÎïåÎ¨∏Ïóê, [React Ïä§ÏºÄÏ§ÑÎü¨Í∞Ä Ïñ¥ÎñªÍ≤å ÏûëÎèô](https://jser.dev/react/2022/03/16/how-react-scheduler-works)ÌïòÎäîÏßÄ ÏÑ§Î™ÖÌï† Îïå Ïñ∏Í∏âÌñàÎìØÏù¥, Í∏∞Î≥∏Ï†ÅÏúºÎ°ú ÏµúÏÜå ÏßÄÏó∞Ïù¥ ÏóÜÎäî Îçî ÎÇòÏùÄ `setTimeout()`Ïù¥ÎùºÍ≥† ÏÉùÍ∞ÅÌï† Ïàò ÏûàÏäµÎãàÎã§.

Îî∞ÎùºÏÑú Î†åÎçîÎßÅ ÎèÑÏ§ë Ïô∏Î∂Ä Ï†ÄÏû•ÏÜåÍ∞Ä Î≥ÄÍ≤ΩÎêòÎ©¥ UIÏùò Îã§Î•∏ Î∂ÄÎ∂ÑÏóêÏÑú ÏÑúÎ°ú Îã§Î•∏ Îç∞Ïù¥ÌÑ∞Í∞Ä Ïª§Î∞ãÎêòÎäî Í≤ÉÏùÑ Î≥º Ïàò ÏûàÏäµÎãàÎã§.

Ïù¥Í≤ÉÏù¥ Ï∞¢ÍπÄ(tear) ÌòÑÏÉÅÏù¥ Î∞úÏÉùÌïòÎäî Ïù¥Ïú†Ïù¥Î©∞, ÏïÑÎûòÎäî Í∑∏ ÏòàÏãúÏûÖÎãàÎã§.

## - App.js

```tsx
import { useEffect, startTransition, useCallback, useState } from "react";

let data = 1;
function getData() {
  return data;
}

setTimeout(() => (data = 2), 100);

function Cell() {
  let start = Date.now();
  while (Date.now() - start < 50) {
    // ÎèôÏãúÏÑ± Î™®ÎìúÏóêÏÑú Î©îÏù∏ Ïä§Î†àÎìúÏóê ÏûëÏóÖÏùÑ ÏñëÎ≥¥Ìï©ÎãàÎã§.
    // 50Î∞ÄÎ¶¨Ï¥à ÎèôÏïà Ïã§Ìñâ ÎêòÏñ¥ Î©îÏù∏ Ïä§Î†àÎìúÎ•º Ï∞®Îã®ÌïòÍ≥†, Î©îÏù∏ Ïä§Î†àÎìúÍ∞Ä
    // Ïù¥ ÏãúÍ∏¥ ÎèôÏïà Îã§Î•∏ ÏûëÏóÖÏùÑ Ï≤òÎ¶¨Ìï† Ïàò ÏóÜÍ≤å ÎßåÎì≠ÎãàÎã§.
  }
  const data = getData();
  return <div style={{ padding: "1rem", border: "1px solid red" }}>{data}</div>;
}

export default function App() {
  const [showCells, setShowCells] = useState(false);

  useEffect(() => {
    startTransition(() => setShowCells(true));
  }, []);
  return (
    <>
      <p>
        Example of tearing. <br />
        below are multiple cells rendering same external data which changes during
        rendering.
      </p>
      {showCells ? (
        <div style={{ display: "flex", gap: "1rem" }}>
          <Cell />
          <Cell />
          <Cell />
          <Cell />
        </div>
      ) : (
        <p>preparing..</p>
      )}
    </>
  );
}
```

Ï∞¢ÍπÄ(tear) ÌòÑÏÉÅÏùÄ ÎèôÏãú Î™®Îìú(concurrent mode)ÏóêÏÑú Î†åÎçîÎßÅÏù¥ Ï§ëÎã®Îê† Í∞ÄÎä•ÏÑ± ÎïåÎ¨∏Ïóê Î∞úÏÉùÌï©ÎãàÎã§.

(ÏúÑ ÏΩîÎìúÏóêÏÑú `startTransition()`ÏùÑ Ï†úÍ±∞ÌïòÎ©¥ Ï∞¢ÍπÄ ÌòÑÏÉÅÏù¥ Ïû¨ÌòÑÎêòÏßÄ ÏïäÏäµÎãàÎã§.)

ReactÎäî ÎÇ¥Î∂Ä Fiber ÏïÑÌÇ§ÌÖçÏ≤òÏóê Ïö∞Î¶¨Í∞Ä Í∞úÏûÖÌïòÎäî Í≤ÉÏùÑ ÌóàÏö©ÌïòÏßÄ ÏïäÍ∏∞ ÎïåÎ¨∏Ïóê, Ïù¥ Î¨∏Ï†úÎ•º Ìï¥Í≤∞Ìï† Î∞©Î≤ïÏù¥ ÏóÜÏäµÎãàÎã§.

Í∑∏ÎûòÏÑú ReactÎäî Ïö∞Î¶¨ÏóêÍ≤å `useSyncExternalStore()`Î•º Ï†úÍ≥µÌï©ÎãàÎã§.

ÏïÑÎûòÎäî ÏúÑ ÏòàÏ†úÏóêÏÑú ÏïΩÍ∞Ñ ÏàòÏ†ïÌïú ÌõÑ `useSyncExternalStore()`Î•º ÏÇ¨Ïö©Ìïú Îç∞Î™®ÏûÖÎãàÎã§.

## - App.js

```ts
import { useEffect, useSyncExternalStore, startTransition, useCallback, useState } from 'react';

let data = 1
function getData() {
  return data
}

setTimeout(() => data = 2, 100)

function Cell() {
  let start = Date.now()
  while (Date.now() - start < 50) {
    // ÎèôÏãúÏÑ± Î™®ÎìúÏóêÏÑú Î©îÏù∏ Ïä§Î†àÎìúÏóê ÏûëÏóÖÏùÑ ÏñëÎ≥¥Ìï©ÎãàÎã§.
    // 50Î∞ÄÎ¶¨Ï¥à ÎèôÏïà Ïã§Ìñâ ÎêòÏñ¥ Î©îÏù∏ Ïä§Î†àÎìúÎ•º Ï∞®Îã®ÌïòÍ≥†, Î©îÏù∏ Ïä§Î†àÎìúÍ∞Ä
    // Ïù¥ ÏãúÍ∏¥ ÎèôÏïà Îã§Î•∏ ÏûëÏóÖÏùÑ Ï≤òÎ¶¨Ìï† Ïàò ÏóÜÍ≤å ÎßåÎì≠ÎãàÎã§.
  }
  const data = useSyncExternalStore(() => {return () => {}},getData);
  return <div style={{padding: '1rem', border: '1px solid red'}}>{data}</div>
}

export default function App() {
  const [showCells, setShowCells] = useState(false)

  useEffect(() => {
    startTransition(() => setShowCells(true))
  }, [])
  return (
    <>
      <p>Example of tearing. <br/>below are multiple cells rendering same external data which changes during rendering.</p>
      {showCells ? <div style={{display: 'flex', gap: '1rem'}}>
        <Cell/><Cell/><Cell/><Cell/>
      </div> : <p>preparing..</p>}
    </>
  );
}
```

Ï∞¢ÍπÄ(tearing) ÌòÑÏÉÅÏù¥ Í≥†Ï≥êÏßÑÍ±∏ Î≥º Ïàò ÏûàÏäµÎãàÎã§.

## 2. Ïñ¥ÎñªÍ≤å useSyncExternalStore()Í∞Ä Î¶¨Ïï°Ìä∏ ÎÇ¥Î∂ÄÏóêÏÑú ÎèôÏûëÌïòÎÇòÏöî ?

ÏöîÏïΩÌïòÏûêÎ©¥, `useSyncExternalStore()`Îäî Ïö∞Î¶¨ÏóêÍ≤å Îëê Í∞ÄÏßÄÎ•º Ï†úÍ≥µÌï©ÎãàÎã§.

1. Ïô∏Î∂Ä Ï†ÄÏû•ÏÜåÏùò Î™®Îì† Î≥ÄÍ≤Ω ÏÇ¨Ìï≠Ïù¥ Í∞êÏßÄÎêòÎèÑÎ°ù Ìï©ÎãàÎã§.

2. ÎèôÏãú Î™®Îìú(concurrent mode)ÏóêÏÑúÎèÑ ÎèôÏùºÌïú Îç∞Ïù¥ÌÑ∞Í∞Ä UIÏóêÏÑú ÎèôÏùºÌïú Ï†ÄÏû•ÏÜåÎ°ú Î†åÎçîÎßÅÎêòÎèÑÎ°ù Ìï©ÎãàÎã§.

Ïù¥Ï†ú React ÎÇ¥Î∂Ä Íµ¨Ï°∞Î•º ÏÇ¥Ìé¥Î≥¥Î©¥ÏÑú Ïù¥Í≤ÉÏù¥ Ïñ¥ÎñªÍ≤å Íµ¨ÌòÑÎêòÎäîÏßÄ ÏïåÏïÑÎ≥¥Í≤†ÏäµÎãàÎã§.

### 2.1 Ï¥àÍ∏∞ ÎßàÏö¥Ìä∏ ÏãúÏóê mountSyncExternalStore()

```ts
function mountSyncExternalStore<T>(
  subscribe: (() => void) => () => void,
  getSnapshot: () => T,
  getServerSnapshot?: () => T,
): T {
  const fiber = currentlyRenderingFiber;
  const hook = mountWorkInProgressHook();
 // ÏÉàÎ°úÏö¥ ÌõÖÏùÑ ÎßåÎì≠ÎãàÎã§.

  let nextSnapshot;
  const isHydrating = getIsHydrating();
  if (isHydrating) {
    ...
  } else {
    nextSnapshot = getSnapshot();
retrieve the data once, just like we did in initializer of useState()

// Î∏îÎ°úÌÇπ Î†àÏù∏ÏùÑ Î†åÎçîÎßÅÌïòÏßÄ ÏïäÎäî Ìïú, ÏùºÍ¥ÄÏÑ± Í≤ÄÏÇ¨Î•º Ïä§ÏºÄÏ§ÑÎßÅÌï©ÎãàÎã§.
// Ïª§Î∞ãÌïòÍ∏∞ ÏßÅÏ†ÑÏóê Ìä∏Î¶¨Î•º ÌÉêÏÉâÌïòÏó¨
// Ïñ¥Îñ§ Ï†ÄÏû•ÏÜåÍ∞Ä Î≥ÄÍ≤ΩÎêòÏóàÎäîÏßÄ ÌôïÏù∏Ìï† Í≤ÉÏûÖÎãàÎã§.
//
// ÏÑúÎ≤Ñ Î†åÎçîÎßÅÎêú ÏΩòÌÖêÏ∏†Î•º ÏàòÎ∂Ñ Í≥µÍ∏â(hydrating)ÌïòÍ≥† ÏûàÎäî Í≤ΩÏö∞ÏóêÎäî Ïù¥Í≤ÉÏùÑ ÏàòÌñâÌïòÏßÄ ÏïäÏäµÎãàÎã§.
// ÏΩòÌÖêÏ∏†Í∞Ä Ïò§ÎûòÎêòÏóàÏùÑ Í≤ΩÏö∞, Ïñ¥Ï∞®Ìîº Ïù¥ÎØ∏ Î≥¥Ïù¥Í≥† ÏûàÍ∏∞ ÎïåÎ¨∏ÏûÖÎãàÎã§.
// ÎåÄÏã†, Ïö∞Î¶¨Îäî Ïù¥Î•º ÏàòÎèô Ìö®Í≥º(passive effect)ÏóêÏÑú ÏàòÏ†ïÌï† Í≤ÉÏûÖÎãàÎã§.

    const root: FiberRoot | null = getWorkInProgressRoot();
    if (!includesBlockingLane(root, renderLanes)) {
      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
    }

// Ïù¥ Î∂ÄÎ∂ÑÏù¥ Ï§ëÏöîÌï©ÎãàÎã§.
// Ïª§Î∞ãÌïòÍ∏∞ ÏßÅÏ†ÑÏóê Ïô∏Î∂Ä Îç∞Ïù¥ÌÑ∞Í∞Ä Î≥ÄÍ≤ΩÎêòÏóàÎäîÏßÄ ÌôïÏù∏ÌïòÎäî Í≤ÄÏÇ¨Î•º Ïä§ÏºÄÏ§ÑÎßÅÌï©ÎãàÎã§.
// Ïù¥Îäî ÎπÑÏ∞®Îã® Î†àÏù∏(non-blocking lane)ÏóêÎßå Ï†ÅÏö©ÎêòÎ©∞, Í∏∞Î≥∏Ï†ÅÏúºÎ°ú Ïù¥Îäî ÎèôÏãú Î™®Îìú(concurrent mode)ÏóêÏÑú ÏûëÎèôÌï®ÏùÑ ÏùòÎØ∏Ìï©ÎãàÎã§.
// Ïù¥Îäî ÏïûÏÑú Ïñ∏Í∏âÌïú Ï∞¢ÍπÄ(tear) ÌòÑÏÉÅÏùÑ Ìï¥Í≤∞ÌïòÎ†§Í≥† ÏãúÎèÑÌïòÎäî Í≤ÉÏûÖÎãàÎã§.

  }

// Îß§ Î†åÎçîÎßÅ ÏãúÎßàÎã§ Ï†ÄÏû•ÏÜåÏóêÏÑú ÌòÑÏû¨ Ïä§ÎÉÖÏÉ∑ÏùÑ ÏùΩÏñ¥ÏòµÎãàÎã§.
// Ïù¥Í≤ÉÏùÄ ReactÏùò ÏùºÎ∞òÏ†ÅÏù∏ Í∑úÏπôÏùÑ Íπ®ÏßÄÎßå, Ï†ÄÏû•ÏÜå ÏóÖÎç∞Ïù¥Ìä∏Îäî Ìï≠ÏÉÅ ÎèôÍ∏∞Ï†ÅÏù¥Í∏∞ ÎïåÎ¨∏Ïóê ÏûëÎèôÌï©ÎãàÎã§.
  hook.memoizedState = nextSnapshot;
// Ïù¥ hoo.memoizedStateÎäî Îç∞Ïù¥ÌÑ∞Î•º Ïú†ÏßÄÌïòÎäî Ïó≠Ìï†ÏùÑ Ìï©ÎãàÎã§.
// Ïö∞Î¶¨Ïùò Íµ¨ÌòÑÏóêÏÑú useState()ÏôÄ ÎèôÏùºÌïú Í∏∞Îä•ÏùÑ Ìï©ÎãàÎã§.

  const inst: StoreInstance<T> = {
    value: nextSnapshot,
    getSnapshot,
  };
  hook.queue = inst;

//Ïù¥Í≤ÉÏùÄ Ïö∞Î¶¨Í∞Ä "ReactÏóêÏÑú useState()Í∞Ä ÎÇ¥Î∂ÄÏ†ÅÏúºÎ°ú Ïñ¥ÎñªÍ≤å ÏûëÎèôÌïòÎäîÍ∞Ä"ÏóêÏÑú Ïñ∏Í∏âÌïú ÏóÖÎç∞Ïù¥Ìä∏ ÌÅêÏôÄ Ïú†ÏÇ¨Ìï¥ Î≥¥Ïù¥ÏßÄÎßå, Ïã§Ï†úÎ°úÎäî ÌïÑÎìú Ïù¥Î¶ÑÎßå ÎπåÎ†§Ïò® Í≤ÉÏûÖÎãàÎã§.

  //Ï†ÄÏû•ÏÜåÏóê Íµ¨ÎèÖÌïòÍ∏∞ ÏúÑÌïú Ìö®Í≥ºÎ•º Ïä§ÏºÄÏ§ÑÎßÅÌï©ÎãàÎã§.
  mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
Great, mountEffect() is the internal of useEffect(), so

it is similar to what we do, scheduling a (passive) effect to init subscription

// Î≥ÄÍ≤Ω Í∞ÄÎä•Ìïú Ïù∏Ïä§ÌÑ¥Ïä§ ÌïÑÎìúÎ•º ÏóÖÎç∞Ïù¥Ìä∏ÌïòÍ∏∞ ÏúÑÌïú Ìö®Í≥ºÎ•º Ïä§ÏºÄÏ§ÑÎßÅÌï©ÎãàÎã§.
// subscribe, getSnapshot ÎòêÎäî Í∞íÏù¥ Î≥ÄÍ≤ΩÎê† ÎïåÎßàÎã§ Ïù¥Î•º ÏóÖÎç∞Ïù¥Ìä∏Ìï† Í≤ÉÏûÖÎãàÎã§.
// Ï†ïÎ¶¨(clean-up) Ìï®ÏàòÍ∞Ä ÏóÜÍ≥†, Ï¢ÖÏÜçÏÑ±ÏùÑ Ïò¨Î∞îÎ•¥Í≤å Ï∂îÏ†ÅÌïòÍ∏∞ ÎïåÎ¨∏Ïóê
// Ï∂îÍ∞Ä ÏÉÅÌÉúÎ•º Ï†ÄÏû•ÌïòÏßÄ ÏïäÍ≥†ÎèÑ ÏßÅÏ†ë pushEffectÎ•º Ìò∏Ï∂úÌï† Ïàò ÏûàÏäµÎãàÎã§.
// Í∞ôÏùÄ Ïù¥Ïú†Î°ú, Ï†ïÏ†Å ÌîåÎûòÍ∑∏Î•º ÏÑ§Ï†ïÌï† ÌïÑÏöîÎèÑ ÏóÜÏäµÎãàÎã§.
// TODO: Ïª§Î∞ã Ï†Ñ ÏùºÍ¥ÄÏÑ± Í≤ÄÏÇ¨Î•º Ï∂îÍ∞ÄÌïòÎ©¥ Ïù¥Î•º ÏàòÎèô Ìö®Í≥º(passive phase)Î°ú Ïù¥ÎèôÌï† Ïàò ÏûàÏäµÎãàÎã§.
// Îã§Ïùå Ï£ºÏÑùÏùÑ Ï∞∏Ï°∞ÌïòÏÑ∏Ïöî.
  fiber.flags |= PassiveEffect;

  // pushEffect : ReactÏóêÏÑú useEffect()Í∞Ä ÎÇ¥Î∂ÄÏ†ÅÏúºÎ°ú Ïñ¥ÎñªÍ≤å ÏûëÎèôÌïòÎäîÏßÄ ÏÑ§Î™ÖÌïú Í≤ÉÍ≥º Ïú†ÏÇ¨Ìï©ÎãàÎã§.
  // Ïù¥Í≤ÉÏùÄ Ìö®Í≥ºÎ•º FiberÏóê Ìë∏ÏãúÌï©ÎãàÎã§.
  pushEffect(


    HookHasEffect | HookPassive,
// HookPassive : ÏàòÎèô Ìö®Í≥º(passive effect)Îäî useEffect()ÏóêÏÑú Ìïú Í≤ÉÍ≥º Ïú†ÏÇ¨ÌïòÎã§Îäî Í≤ÉÏùÑ ÏùòÎØ∏Ìï©ÎãàÎã§.

    updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot),
// updateStoreInstance :
// Ï¥àÍ∏∞ ÎßàÏö¥Ìä∏ Ïãú, nextSnapshotÏù¥ ÎèôÏùºÌïòÍ∏∞ ÎïåÎ¨∏Ïóê Í≤ÄÏÇ¨Ïùò Ïù¥Ï†êÏùÑ Ï∑®Ìï©ÎãàÎã§. Ïù¥Î°†Ï†ÅÏúºÎ°ú 314Î≤à Ï§ÑÏùò getSnapshot()Í≥º 359Î≤à Ï§ÑÏùò mountEffect() ÏÇ¨Ïù¥Ïóê ÏûëÏùÄ Ï∞ΩÏù¥ ÏûàÍ∏∞ ÎïåÎ¨∏ÏûÖÎãàÎã§. Ï∞¢ÍπÄ(tear) Î¨∏Ï†úÎ•º Ìï¥Í≤∞ÌïòÍ∏∞ ÏúÑÌïú ÏùºÍ¥ÄÏÑ± Í≤ÄÏÇ¨ÏôÄÎäî Îã¨Î¶¨, ÏµúÏã† Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÎäîÏßÄ ÌôïÏù∏ÌïòÍ∏∞ ÏúÑÌï¥ Îã§Ïãú Î†åÎçîÎßÅÌï©ÎãàÎã§. Ïù¥Îäî Ïö∞Î¶¨Ïùò Íµ¨ÌòÑÏóêÏÑú update()Î•º Îã§Ïãú Ìò∏Ï∂úÌïòÎäî Î™©Ï†ÅÍ≥º Ïú†ÏÇ¨Ìï©ÎãàÎã§.

    undefined,
    null,
  );
  return nextSnapshot;
}
function subscribeToStore(fiber, inst, subscribe) {
  const handleStoreChange = () => {
// Ï†ÄÏû•ÏÜåÍ∞Ä Î≥ÄÍ≤ΩÎêòÏóàÏäµÎãàÎã§.
// ÎßàÏßÄÎßâÏúºÎ°ú Ï†ÄÏû•ÏÜåÏóêÏÑú ÏùΩÏùÄ Ïù¥ÌõÑ Ïä§ÎÉÖÏÉ∑Ïù¥ Î≥ÄÍ≤ΩÎêòÏóàÎäîÏßÄ ÌôïÏù∏Ìï©ÎãàÎã§.
    if (checkIfSnapshotChanged(inst)) {
      // Î¶¨Î†åÎçîÎßÅÏùÑ Í∞ïÏ†úÌï©ÎãàÎã§.
      forceStoreRerender(fiber);
    }
  };
// Ï†ÄÏû•ÏÜåÏóê Íµ¨ÎèÖÌïòÍ≥† Ï†ïÎ¶¨(clean-up) Ìï®ÏàòÎ•º Î∞òÌôòÌï©ÎãàÎã§.
  return subscribe(handleStoreChange);
}
function updateStoreInstance<T>(
  fiber: Fiber,
  inst: StoreInstance<T>,
  nextSnapshot: T,
  getSnapshot: () => T,
) {
// Ïù¥Í≤ÉÎì§ÏùÄ ÏàòÎèô Îã®Í≥ÑÏóêÏÑú ÏóÖÎç∞Ïù¥Ìä∏Îê©ÎãàÎã§.
  inst.value = nextSnapshot;
  inst.getSnapshot = getSnapshot;

// Î†åÎçîÏôÄ Ïª§Î∞ã ÏÇ¨Ïù¥Ïóê Î¨¥Ïñ∏Í∞ÄÍ∞Ä Î≥ÄÍ≤ΩÎêòÏóàÏùÑ Ïàò ÏûàÏäµÎãàÎã§.
// Ïù¥Í≤ÉÏùÄ ÏàòÎèô Ìö®Í≥ºÍ∞Ä Ïã§ÌñâÎêòÍ∏∞ Ï†ÑÏóê Î∞úÏÉùÌïú Ïù¥Î≤§Ìä∏ÏóêÏÑú Î∞úÏÉùÌñàÏùÑ ÏàòÎèÑ ÏûàÍ≥†,
// Î†àÏù¥ÏïÑÏõÉ Ìö®Í≥ºÏóêÏÑú Î∞úÏÉùÌñàÏùÑ ÏàòÎèÑ ÏûàÏäµÎãàÎã§.
// Í∑∏Îü∞ Í≤ΩÏö∞ÏóêÎäî Ïù¥Ï†Ñ Ïä§ÎÉÖÏÉ∑Í≥º getSnapshot Í∞íÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ Îπ†Ï†∏ÎÇòÍ∞îÏùÑ Í≤ÉÏûÖÎãàÎã§.
// Ìïú Î≤à Îçî ÌôïÏù∏Ìï¥Ïïº Ìï©ÎãàÎã§.

  if (checkIfSnapshotChanged(inst)) {
   // Î¶¨Î†åÎçîÎßÅÏùÑ Îã§Ïãú Í∞ïÏ†úÌï©ÎãàÎã§.
    forceStoreRerender(fiber);
  }
}
function checkIfSnapshotChanged(inst) {
  const latestGetSnapshot = inst.getSnapshot;
  const prevValue = inst.value;
  try {
    const nextValue = latestGetSnapshot();
    return !is(prevValue, nextValue);
 // subscribeToStore()ÏôÄ updateStoreInstance() Îëò Îã§ÏóêÏÑú,
// Ïù¥ Í≤ÄÏÇ¨Îäî Ïô∏Î∂Ä Îç∞Ïù¥ÌÑ∞Í∞Ä Î≥ÄÍ≤ΩÎê† Í≤ΩÏö∞ Î¶¨Î†åÎçîÎßÅÏù¥ Ïä§ÏºÄÏ§ÑÎßÅÎêòÎèÑÎ°ù Î≥¥Ïû•Ìï©ÎãàÎã§.

  } catch (error) {
    return true;
  }
}
function forceStoreRerender(fiber) {
  const root = enqueueConcurrentRenderForLane(fiber, SyncLane);
  if (root !== null) {
    scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);

// SyncLane : Ïó¨Í∏∞ÏÑú Î¶¨Î†åÎçîÎßÅÏùÑ ÏúÑÌï¥ SyncLaneÏùÑ Í∞ïÏ†úÌï©ÎãàÎã§. ReactÍ∞Ä Ï¥àÍ∏∞ ÎßàÏö¥Ìä∏Î•º Ïñ¥ÎñªÍ≤å ÏàòÌñâÌïòÎäîÏßÄ ÏÑ§Î™ÖÌñàÎìØÏù¥, SyncLaneÏùÄ Î∏îÎ°úÌÇπ Î†àÏù∏ÏûÖÎãàÎã§. Îî∞ÎùºÏÑú Ïù¥ ÏÉàÎ°úÏö¥ Î†åÎçîÎßÅÏùÄ ÎèôÏãú Î™®ÎìúÏóêÏÑú Ïã§ÌñâÎêòÏßÄ ÏïäÏäµÎãàÎã§. Ï∞¢ÍπÄ(tear) ÌòÑÏÉÅÏùÄ ÎèôÏãú Î™®ÎìúÏóêÏÑúÎßå Î∞úÏÉùÌïòÍ∏∞ ÎïåÎ¨∏Ïóê, Ïù¥Îäî Îã§Ïùå Î†åÎçîÎßÅÏóêÏÑú Ï∞¢ÍπÄ ÌòÑÏÉÅÏù¥ Î∞úÏÉùÌïòÏßÄ ÏïäÎèÑÎ°ù Î∞©ÏßÄÌï©ÎãàÎã§.

  }
}
```

ÏΩîÎìúÎäî Îã§ÏÜå Î≥µÏû°ÌïòÏßÄÎßå, ÏïÑÏù¥ÎîîÏñ¥Îäî Í∞ÑÎã®Ìï©ÎãàÎã§.

Ï§ëÏöîÌïòÍ≤å Î≥¥ÏïÑÏïºÌï† Ï†êÏùÄ ÏùºÍ¥ÄÏÑ± Í≤ÄÏÇ¨Í∞Ä Ïñ¥ÎñªÍ≤å ÏûëÎèôÌïòÎäîÏßÄÏûÖÎãàÎã§.

Í≥ÑÏÜçÌï¥ÏÑú ÏÇ¥Ìé¥Î≥¥Í≤†ÏäµÎãàÎã§.

### 2.2 Î¶¨Î†åÎçîÎßÅ ÏïàÏóêÏÑú updateSyncExternalStore()Í∞Ä Ïñ¥ÎñªÍ≤å ÎèôÏûëÌïòÎäîÍ∞Ä

```ts

function updateSyncExternalStore<T>(
  subscribe: (() => void) => () => void,
  getSnapshot: () => T,
  getServerSnapshot?: () => T,
): T {
  const fiber = currentlyRenderingFiber;
  const hook = updateWorkInProgressHook();
// Îß§ Î†åÎçîÎßÅÎßàÎã§ Ï†ÄÏû•ÏÜåÏóêÏÑú ÌòÑÏû¨ Ïä§ÎÉÖÏÉ∑ÏùÑ ÏùΩÏñ¥ÏòµÎãàÎã§.
// Ïù¥Îäî ReactÏùò ÏùºÎ∞ò Í∑úÏπôÏùÑ Íπ®Îú®Î¶¨ÏßÄÎßå, Ï†ÄÏû•ÏÜå ÏóÖÎç∞Ïù¥Ìä∏Í∞Ä Ìï≠ÏÉÅ ÎèôÍ∏∞Ï†ÅÏúºÎ°ú Ïù¥Î£®Ïñ¥ÏßÄÍ∏∞ ÎïåÎ¨∏Ïóê ÏûëÎèôÌï©ÎãàÎã§.
  const nextSnapshot = getSnapshot();

  const prevSnapshot = hook.memoizedState;
  const snapshotChanged = !is(prevSnapshot, nextSnapshot);
  if (snapshotChanged) {
    hook.memoizedState = nextSnapshot;
 //  Îî∞ÎùºÏÑú ÏÉàÎ°úÏö¥ ÏÉÅÌÉúÍ∞Ä Î∞úÍ≤¨ÎêòÎ©¥, Îç∞Ïù¥ÌÑ∞Î•º Ï¶âÏãú ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§.

    markWorkInProgressReceivedUpdate();
  }
  const inst = hook.queue;
  updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
    subscribe,
  ]);
// Ïù¥Îäî Ï¢ÖÏÜçÏÑ±(deps)Ïóê Îî∞Îùº ÏóÖÎç∞Ïù¥Ìä∏ÏôÄ Ï†ïÎ¶¨Î•º ÏàòÌñâÌïòÍ∏∞ ÏúÑÌï¥ useEffect()Î•º Îî∞Î¶ÖÎãàÎã§.

// getSnapshot ÎòêÎäî subscribeÍ∞Ä Î≥ÄÍ≤ΩÎê† ÎïåÎßàÎã§,
// Ïª§Î∞ã Îã®Í≥ÑÏóêÏÑú Ï§ëÏ≤©Îêú Î≥ÄÍ≤ΩÏù¥ ÏûàÏóàÎäîÏßÄ ÌôïÏù∏Ìï¥Ïïº Ìï©ÎãàÎã§.
// ÎèôÏãú Î™®ÎìúÏóêÏÑúÎäî Ïù¥Îü¨Ìïú ÏùºÏù¥ ÏûêÏ£º Î∞úÏÉùÌï† Ïàò ÏûàÏßÄÎßå,
// Ïã¨ÏßÄÏñ¥ ÎèôÍ∏∞ Î™®ÎìúÏóêÏÑúÎèÑ Ïù¥Ï†Ñ Ìö®Í≥ºÍ∞Ä Ï†ÄÏû•ÏÜåÎ•º Î≥ÄÍ≤ΩÌñàÏùÑ Ïàò ÏûàÏäµÎãàÎã§.
  if (
    inst.getSnapshot !== getSnapshot ||
    snapshotChanged ||
// subscribe Ìï®ÏàòÍ∞Ä Î≥ÄÍ≤ΩÎêòÏóàÎäîÏßÄ ÌôïÏù∏Ìï©ÎãàÎã§.
// ÏúÑÏóêÏÑú Íµ¨ÎèÖ Ìö®Í≥ºÎ•º Ïä§ÏºÄÏ§ÑÎßÅÌñàÎäîÏßÄ ÌôïÏù∏Ìï®ÏúºÎ°úÏç® Î©îÎ™®Î¶¨Î•º Ï†àÏïΩÌï† Ïàò ÏûàÏäµÎãàÎã§.
    (workInProgressHook !== null &&
      workInProgressHook.memoizedState.tag & HookHasEffect)
  ) {
    fiber.flags |= PassiveEffect;
    pushEffect(
      HookHasEffect | HookPassive,
      updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot),
      undefined,
      null,
    );
//  getSnapshot()Ïù¥ Î≥ÄÍ≤ΩÎêòÎ©¥, ÏùòÏ°¥ÏÑ± Î∞∞Ïó¥Ïù¥ Î≥ÄÍ≤ΩÎê† Îïå useEffect()Î•º ÏóÖÎç∞Ïù¥Ìä∏ÌïòÎäî Í≤ÉÏ≤òÎüº Ìö®Í≥ºÎ•º ÏóÖÎç∞Ïù¥Ìä∏Ìï¥Ïïº Ìï©ÎãàÎã§.

// Î∏îÎ°úÌÇπ Î†àÏù∏ÏùÑ Î†åÎçîÎßÅÌïòÏßÄ ÏïäÎäî Ìïú, ÏùºÍ¥ÄÏÑ± Í≤ÄÏÇ¨Î•º Ïä§ÏºÄÏ§ÑÎßÅÌï©ÎãàÎã§.
// Ïª§Î∞ã ÏßÅÏ†ÑÏóê Ìä∏Î¶¨Î•º ÌÉêÏÉâÌïòÏó¨ Ï†ÄÏû•ÏÜåÍ∞Ä Î≥ÄÍ≤ΩÎêòÏóàÎäîÏßÄ ÌôïÏù∏Ìï† Í≤ÉÏûÖÎãàÎã§.
    const root: FiberRoot | null = getWorkInProgressRoot();
    if (root === null) {
      throw new Error(
        'Expected a work-in-progress root. This is a bug in React. Please file an issue.',
      );
    }
    if (!includesBlockingLane(root, renderLanes)) {
      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
    }
// Ïó¨Í∏∞ÏÑú ÏùºÍ¥ÄÏÑ± Í≤ÄÏÇ¨Í∞Ä Îã§Ïãú Ïä§ÏºÄÏ§ÑÎßÅÎê©ÎãàÎã§.
// ÏÜîÏßÅÌûà ÎßêÌï¥, Ïôú Ïó¨Í∏∞Ïóê Î∞∞ÏπòÎêòÏóàÎäîÏßÄ Ïûò Ïù¥Ìï¥Í∞Ä ÎêòÏßÄ ÏïäÏäµÎãàÎã§...

// Ïä§ÎÉÖÏÉ∑ Î≥ÄÌôîÏôÄ getSnapshot() Î≥ÄÌôîÍ∞Ä ÏóÜÎçîÎùºÎèÑ Ïô∏Î∂Ä Ï†ÄÏû•ÏÜåÍ∞Ä Ïö∞Î¶¨ÏóêÍ≤å ÏïåÎ¶¨ÏßÄ ÏïäÍ≥† Î≥ÄÍ≤ΩÎê† Í∞ÄÎä•ÏÑ±ÏùÄ Ïó¨Ï†ÑÌûà ÏûàÏäµÎãàÎã§(ÏòàÎ•º Îì§Ïñ¥, Ïì∞Î°úÌãÄÎêú Ïù¥Î≤§Ìä∏Î•º ÏÉùÍ∞ÅÌï¥Î≥¥ÏÑ∏Ïöî). Îî∞ÎùºÏÑú Ïù¥ Ï°∞Í±¥ÏóêÏÑú Í≤ÄÏÇ¨Î•º Ïó¨Í∏∞Ïóê ÎëêÎäî Í≤ÉÏùÄ Î≤ÑÍ∑∏Ï≤òÎüº Î≥¥ÏûÖÎãàÎã§.

// 2023-08-11 ÏóÖÎç∞Ïù¥Ìä∏:

// Ïù¥Í≤ÉÏùÄ Î≤ÑÍ∑∏Í∞Ä ÏïÑÎãàÏóàÏäµÎãàÎã§. Ïó¨Í∏∞ÏÑúÎäî Ï£ºÎ°ú subscribe()ÏôÄ getSnapshot()Ïùò Î≥ÄÍ≤ΩÏóê ÎåÄÌï¥ ÏùºÍ¥ÄÏÑ± Í≤ÄÏÇ¨Î•º Ïä§ÏºÄÏ§ÑÎßÅÌï©ÎãàÎã§. PRÏùÑ ÌôïÏù∏Ìï¥Î≥¥ÏÑ∏Ïöî. (https://github.com/facebook/react/pull/27180)

  }
  return nextSnapshot;
}
```

ÏΩîÎìúÎäî ÏùºÍ¥ÄÏÑ± Í≤ÄÏÇ¨Î•º Ïä§ÏºÄÏ§ÑÎßÅÌïòÎäî ÎßàÏßÄÎßâ Î∂ÄÎ∂ÑÏùÑ Ï†úÏô∏ÌïòÍ≥†Îäî Ìï©Î¶¨Ï†ÅÏúºÎ°ú Î≥¥ÏûÖÎãàÎã§.

ÌäπÏ†ï Ï°∞Í±¥ ÌïòÏóêÏÑú ÏòàÏÉÅÎåÄÎ°ú ÏûëÎèôÌïòÏßÄ ÏïäÎäîÎã§Îäî Í≤ÉÏùÑ Î≥¥Ïó¨Ï£ºÎäî Îç∞Î™®Î•º ÏûëÏÑ±ÌñàÏäµÎãàÎã§.

## - App.js

```ts

import {
  useEffect,
  useSyncExternalStore,
  startTransition,
  useState,
  useLayoutEffect,
  useMemo,
} from 'react';

let data = 1;
let callbacks = [];

function getSnapShot() {
  return data;
}

setTimeout(() => (data = 2), 800);

function subscribe(callback) {
  callbacks.push(callback);
  return () => {
    callbacks = callbacks.filter((item) => item != callback);
  };
}

function Cell() {
  let start = Date.now();
  while (Date.now() - start < 50) {
    // force yielding to main thread in concurrent mode
  }
  const data = useSyncExternalStore(subscribe, getSnapShot);

  return <div style={{ padding: '1rem', border: '1px solid red' }}>{data}</div>;
}

export default function App() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    startTransition(() => {
      setCount((count) => count + 1);
    });
  }, []);

  return (
    <div>
      <p>
        Example of tearing. <br />
        below are multiple cells rendering same external data which changes
        during rendering.
      </p>
      <div style={{ display: 'flex', gap: '1rem' }}>
        <Cell />
        <Cell />
        <Cell />
        <Cell />
        <Cell />
        <Cell />
      </div>
    </div>
  );
}
```

Ïó¨Í∏∞ÏÑú useSyncExternalStore()Î•º ÏÇ¨Ïö©ÌñàÏùåÏóêÎèÑ Î∂àÍµ¨ÌïòÍ≥† Ï∞¢ÍπÄ(tear) ÌòÑÏÉÅÏù¥ Îã§Ïãú Î∞úÏÉùÌïòÎäî Í≤ÉÏùÑ Î≥º Ïàò ÏûàÏäµÎãàÎã§.

Ïù¥Îäî Î≤ÑÍ∑∏Ïùº Í∞ÄÎä•ÏÑ±Ïù¥ ÏûàÏúºÎ©∞, Ïù¥Î•º ÏàòÏ†ïÌïòÍ∏∞ ÏúÑÌï¥ [ÌíÄ Î¶¨ÌÄòÏä§Ìä∏](https://github.com/facebook/react/pull/27180)Î•º ÏûëÏÑ±ÌñàÏäµÎãàÎã§.

> ÎßåÏïΩ Ï∞¢ÍπÄ(tear) ÌòÑÏÉÅÏù¥ Î≥¥Ïù¥ÏßÄ ÏïäÎäîÎã§Î©¥, ÏΩîÎìúÏóêÏÑú ÌÉÄÏûÑÏïÑÏõÉÏùÑ Îçî ÏûëÏùÄ Í∞íÏúºÎ°ú Î≥ÄÍ≤ΩÌï¥Î≥¥ÏÑ∏Ïöî.

> 2023-08-11 ÏóÖÎç∞Ïù¥Ìä∏: ÏùºÍ¥ÄÏÑ± Í≤ÄÏÇ¨Í∞Ä ÌïòÎäî Ïó≠Ìï†ÏùÑ Ïò§Ìï¥Ìïú Í≤ÉÏúºÎ°ú ÎìúÎü¨ÎÇ¨ÏäµÎãàÎã§. useSyncExternalStore()Îäî Î™®Îì† Ïô∏Î∂Ä Ï†ÄÏû•ÏÜå Îç∞Ïù¥ÌÑ∞ Î≥ÄÍ≤ΩÏù¥ Î∞òÎìúÏãú Î∞úÏÉùÌïòÎèÑÎ°ù ÏöîÍµ¨Ìï©ÎãàÎã§. Í∑∏ÎûòÏÑú subscribe() ÎÇ¥Î∂ÄÏùò forceStoreRerender()Í∞Ä Ïô∏Î∂Ä Îç∞Ïù¥ÌÑ∞ Î≥ÄÍ≤ΩÏúºÎ°ú Ïù∏Ìïú Ï∞¢ÍπÄ ÌòÑÏÉÅÏùÑ Ïã§Ï†úÎ°ú Î∞©ÏßÄÌïòÎäî Í≤ÉÏûÖÎãàÎã§. Ïó¨Í∏∞ÏÑú ÏùºÍ¥ÄÏÑ± Í≤ÄÏÇ¨Îäî subscribe() ÎòêÎäî getSnapshot()Ïùò Î≥ÄÍ≤ΩÏúºÎ°ú Ïù∏Ìïú Ï∞¢ÍπÄÏùÑ Î∞©ÏßÄÌï©ÎãàÎã§.

### 2.3 ÎèôÏãúÏÑ± Î™®ÎìúÏóêÏÑú ÏùºÍ¥ÄÏÑ± ÌôïÏù∏

Ïñ¥ÎñªÍ≤å ÏùºÍ¥ÄÏÑ± Ï≤¥ÌÅ¨Í∞Ä Ïù¥Î£®Ïñ¥ÏßÄÎäîÏßÄ ÌïúÎ≤à Ï∞æÏïÑÎ¥ÖÏãúÎã§.

```ts
function pushStoreConsistencyCheck<T>(
  fiber: Fiber,
  getSnapshot: () => T,
  renderedSnapshot: T,
) {
  fiber.flags |= StoreConsistency;
  const check: StoreConsistencyCheck<T> = {
    getSnapshot,
    value: renderedSnapshot,
  };
  let componentUpdateQueue: null | FunctionComponentUpdateQueue = (currentlyRenderingFiber.updateQueue: any);
  if (componentUpdateQueue === null) {
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any);

// currentlyRenderingFiber.updateQueue :  useEffectÎ•º ÏÉÅÍ∏∞Ìï¥Î≥¥Î©¥, updateQueueÎäî Ìö®Í≥ºÎì§ÏùÑ Ï†ÄÏû•ÌïòÍ∏∞ ÏúÑÌï¥ lastEffectÎèÑ Î≥¥Ïú†ÌïòÍ≥† ÏûàÏäµÎãàÎã§. Í∑∏Î¶¨Í≥† renderWithHooks()ÏóêÏÑú Ïù¥Í≤ÉÏù¥ ÏßÄÏõåÏßÄÎØÄÎ°ú, Ïª¥Ìè¨ÎÑåÌä∏Í∞Ä Î†åÎçîÎßÅÎê† ÎïåÎßàÎã§ ÏÉàÎ°≠Í≤å ÏãúÏûëÎê©ÎãàÎã§.

    componentUpdateQueue.stores = [check];
// componentUpdateQueue.stores :  Ïô∏Î∂Ä Ï†ÄÏû•ÏÜå Í≤ÄÏÇ¨Î•º ÏúÑÌïú Î≥ÑÎèÑÏùò ÌïÑÎìúÏûÖÎãàÎã§.

  } else {
    const stores = componentUpdateQueue.stores;
    if (stores === null) {
      componentUpdateQueue.stores = [check];
    } else {
      stores.push(check);
    }
  }
}
```

Ïù¥Ï†ú ÏùºÍ¥ÄÏÑ± Í≤ÄÏÇ¨Í∞Ä Ïñ∏Ï†ú Í∑∏Î¶¨Í≥† Ïñ¥ÎñªÍ≤å Ìä∏Î¶¨Í±∞ÎêòÎäîÏßÄ Î≥º Ï∞®Î°ÄÏûÖÎãàÎã§.

Ïù¥Îäî Ïã§Ï†úÎ°ú Ïª§Î∞ã ÏßÅÏ†ÑÏóê, Î†åÎçî Îã®Í≥ÑÏùò ÎÅùÏóêÏÑú Ïã§ÌñâÎê©ÎãàÎã§.

```ts
// Ïù¥ Ìï®ÏàòÎäî Î™®Îì† ÎèôÏãú ÏûëÏóÖÏùò ÏßÑÏûÖÏ†êÏûÖÎãàÎã§. Ï¶â, SchedulerÎ•º ÌÜµÌï¥
// ÏßÑÌñâÎêòÎäî Î™®Îì† ÏûëÏóÖÏùÄ Ïó¨Í∏∞Î°ú Îì§Ïñ¥ÏòµÎãàÎã§.
export function performConcurrentWorkOnRoot(
  root: FiberRoot,
  didTimeout: boolean,
): RenderTaskFn | null {
  ...
  // Î£®Ìä∏Ïóê Ï†ÄÏû•Îêú ÌïÑÎìúÎ•º ÏÇ¨Ïö©ÌïòÏó¨ Îã§Ïùå ÏûëÏóÖÌï† Î†àÏù∏ÏùÑ Í≤∞Ï†ïÌï©ÎãàÎã§.
  // TODO: Ìò∏Ï∂úÏûêÏóêÏÑú Ïù¥ÎØ∏ Í≥ÑÏÇ∞Ìïú Í∞íÏûÖÎãàÎã§. Ïù∏ÏàòÎ°ú Ï†ÑÎã¨ÌïòÎèÑÎ°ù ÏàòÏ†ïÌï¥Ïïº Ìï©ÎãàÎã§.
  let lanes = getNextLanes(
    root,
    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,
  );
  if (lanes === NoLanes) {
    // Î∞©Ïñ¥Ï†Å ÏΩîÎî©. Ïù¥ Í≤ΩÏö∞Îäî Î∞úÏÉùÌïòÏßÄ ÏïäÏïÑÏïº Ìï©ÎãàÎã§.
    return null;
  }
  // ÌäπÏ†ï Í≤ΩÏö∞ÏóêÎäî ÏãúÍ∞Ñ Î∂ÑÌï†ÏùÑ ÎπÑÌôúÏÑ±ÌôîÌï©ÎãàÎã§: ÏûëÏóÖÏù¥ ÎÑàÎ¨¥ Ïò§Îûò CPUÏóê Î¨∂Ïó¨ ÏûàÏóàÏùÑ Í≤ΩÏö∞("ÎßåÎ£åÎêú" ÏûëÏóÖÏúºÎ°ú, Í∏∞ÏïÑÎ•º Î∞©ÏßÄÌïòÍ∏∞ ÏúÑÌï®) ÎòêÎäî ÎèôÍ∏∞ ÏóÖÎç∞Ïù¥Ìä∏ Í∏∞Î≥∏ Î™®ÎìúÏùº Í≤ΩÏö∞.
  // TODO: Scheduler Î≤ÑÍ∑∏Î•º Ï°∞ÏÇ¨ Ï§ëÏù¥Îùº, Î∞©Ïñ¥Ï†ÅÏúºÎ°ú `didTimeout`ÏùÑ Ï≤¥ÌÅ¨Ìï©ÎãàÎã§.
  // SchedulerÏùò Î≤ÑÍ∑∏Í∞Ä ÏàòÏ†ïÎêòÎ©¥ Ïù¥Î•º Ï†úÍ±∞Ìï† Ïàò ÏûàÏäµÎãàÎã§. Ïö∞Î¶¨Îäî ÎßåÎ£åÎ•º ÏûêÏ≤¥Ï†ÅÏúºÎ°ú Ï∂îÏ†ÅÌï©ÎãàÎã§.
  const shouldTimeSlice =
    !includesBlockingLane(root, lanes) &&
    !includesExpiredLane(root, lanes) &&
    (disableSchedulerTimeoutInWorkLoop || !didTimeout);
  let exitStatus = shouldTimeSlice
    ? renderRootConcurrent(root, lanes)
    : renderRootSync(root, lanes);

  if (exitStatus !== RootInProgress) {
    if (exitStatus === RootErrored) {
      // Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏùÑ Í≤ΩÏö∞, Ìïú Î≤à Îçî Î†åÎçîÎßÅÏùÑ ÏãúÎèÑÌï©ÎãàÎã§.
      // ÎèôÏãú Îç∞Ïù¥ÌÑ∞ Î≥ÄÏ°∞Î•º ÎßâÍ∏∞ ÏúÑÌï¥ ÎèôÍ∏∞Ï†ÅÏúºÎ°ú Î†åÎçîÎßÅÌïòÍ≥†, Î™®Îì† Î≥¥Î•ò Ï§ëÏù∏ ÏóÖÎç∞Ïù¥Ìä∏Í∞Ä Ìè¨Ìï®ÎêòÎèÑÎ°ù Ìï©ÎãàÎã§.
      // Îëê Î≤àÏß∏ ÏãúÎèÑ ÌõÑÏóêÎèÑ Ïã§Ìå®ÌïòÎ©¥ Í≤∞Í≥º Ìä∏Î¶¨Î•º Ïª§Î∞ãÌï©ÎãàÎã§.
      const originallyAttemptedLanes = lanes;
      const errorRetryLanes = getLanesToRetrySynchronouslyOnError(
        root,
        originallyAttemptedLanes,
      );
      if (errorRetryLanes !== NoLanes) {
        lanes = errorRetryLanes;
        exitStatus = recoverFromConcurrentError(
          root,
          originallyAttemptedLanes,
          errorRetryLanes,
        );
      }
    }
    if (exitStatus === RootFatalErrored) {
      const fatalError = workInProgressRootFatalError;
      prepareFreshStack(root, NoLanes);
      markRootSuspended(root, lanes);
      ensureRootIsScheduled(root);
      throw fatalError;
    }
    if (exitStatus === RootDidNotComplete) {
      // Ìä∏Î¶¨Î•º ÏôÑÏÑ±ÌïòÏßÄ Î™ªÌïòÍ≥† Î†åÎçîÎßÅÏù¥ Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§. Ïù¥Îäî ÏùºÍ¥ÄÎêú Ìä∏Î¶¨Î•º ÏÉùÏÑ±ÌïòÍ±∞ÎÇò Ïª§Î∞ãÌïòÏßÄ ÏïäÍ≥†
      // ÌòÑÏû¨ Î†åÎçîÎßÅÏùÑ Ï¢ÖÎ£åÌï¥Ïïº ÌïòÎäî ÌäπÏàòÌïú Í≤ΩÏö∞Ïóê Î∞úÏÉùÌï©ÎãàÎã§.
      markRootSuspended(root, lanes);
    } else {
      // Î†åÎçîÎßÅÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§.
      // Ïù¥ Î†åÎçîÎßÅÏù¥ ÎèôÏãú Ïù¥Î≤§Ìä∏Ïóê ÏñëÎ≥¥ÌñàÏùÑ Í∞ÄÎä•ÏÑ±Ïù¥ ÏûàÎäîÏßÄ ÌôïÏù∏ÌïòÍ≥†, Í∑∏Îü∞ Í≤ΩÏö∞
      // ÏÉàÎ°ú Î†åÎçîÎßÅÎêú Ïä§ÌÜ†Ïñ¥Í∞Ä ÏùºÍ¥ÄÎêúÏßÄ ÌôïÏù∏Ìï©ÎãàÎã§.
      // TODO: Î†åÎçîÎßÅÏù¥ Ï∂©Î∂ÑÌûà Îπ†Î•¥Í±∞ÎÇò ÎßåÎ£åÎêú Í≤ΩÏö∞ Ï£º Ïä§Î†àÎìúÏóê ÏñëÎ≥¥ÌïòÏßÄ ÏïäÏïòÏùÑ ÏàòÎèÑ ÏûàÏäµÎãàÎã§. Í∑∏Îü∞ Í≤ΩÏö∞ ÏùºÍ¥ÄÏÑ± Í≤ÄÏÇ¨Î•º ÏÉùÎûµÌï† Ïàò ÏûàÏäµÎãàÎã§.
      const renderWasConcurrent = !includesBlockingLane(root, lanes);
      const finishedWork: Fiber = (root.current.alternate: any);
      if (
        renderWasConcurrent &&
        !isRenderConsistentWithExternalStores(finishedWork)
        // Ïó¨Í∏∞ÏÑú ÏùºÍ¥ÄÏÑ± Ï≤¥ÌÅ¨Í∞Ä ÏùºÏñ¥ÎÇ©ÎãàÎã§.
      ) {
        // Ïä§ÌÜ†Ïñ¥Í∞Ä ÍµêÏ∞® Ïù¥Î≤§Ìä∏ÏóêÏÑú Î≥ÄÏ°∞ÎêòÏóàÏäµÎãàÎã§. ÎèôÏãú Î≥ÄÏ°∞Î•º ÎßâÍ∏∞ ÏúÑÌï¥ ÎèôÍ∏∞Ï†ÅÏúºÎ°ú Îã§Ïãú Î†åÎçîÎßÅÌï©ÎãàÎã§.
        exitStatus = renderRootSync(root, lanes);
        // exitStatus = renderRootSync(root, lanes) : ÎèôÍ∏∞ Î™®ÎìúÏóêÏÑú Îã§Ïãú Î†åÎçîÎßÅÏù¥ ÏãúÏûëÎê©ÎãàÎã§.
        // Ïª§Î∞ãÏù¥ Î∞úÏÉùÌïòÍ∏∞ Ï†ÑÏóê, ÏÇ¨Ïö©ÏûêÎì§ÏùÄ UIÏóêÏÑú Ï∞¢Ïñ¥Ïßê(ÌôîÎ©¥ ÍπúÎπ°ÏûÑ Îì±)ÏùÑ Î≥¥ÏßÄ ÏïäÍ≤å Îê©ÎãàÎã§.

        // Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÎäîÏßÄ Îã§Ïãú ÌôïÏù∏Ìï¥Ïïº Ìï©ÎãàÎã§.
        if (exitStatus === RootErrored) {
          const originallyAttemptedLanes = lanes;
          const errorRetryLanes = getLanesToRetrySynchronouslyOnError(
            root,
            originallyAttemptedLanes,
          );
          if (errorRetryLanes !== NoLanes) {
            lanes = errorRetryLanes;
            exitStatus = recoverFromConcurrentError(
              root,
              originallyAttemptedLanes,
              errorRetryLanes,
            );
            // ÎèôÏãú Ïù¥Î≤§Ìä∏Ïóê ÏñëÎ≥¥ÌïòÏßÄ ÏïäÏïòÏúºÎØÄÎ°ú Ïù¥Ï†ú Ìä∏Î¶¨Í∞Ä ÏùºÍ¥ÄÎêòÎã§Í≥† Í∞ÄÏ†ïÌï©ÎãàÎã§.
          }
        }
        if (exitStatus === RootFatalErrored) {
          const fatalError = workInProgressRootFatalError;
          prepareFreshStack(root, NoLanes);
          markRootSuspended(root, lanes);
          ensureRootIsScheduled(root);
          throw fatalError;
        }
        // FIXME: RootDidNotCompleteÎ•º Îã§Ïãú ÌôïÏù∏Ìï¥Ïïº Ìï©ÎãàÎã§. ÌòÑÏû¨ Íµ¨Ï°∞Í∞Ä Ïù¥ÏÉÅÏ†ÅÏù¥ÏßÄ ÏïäÏäµÎãàÎã§.
      }
      // Ïù¥Ï†ú Ìä∏Î¶¨Í∞Ä ÏùºÍ¥ÄÎêú ÏÉÅÌÉúÏûÖÎãàÎã§. Îã§Ïùå Îã®Í≥ÑÎäî Ïù¥Î•º Ïª§Î∞ãÌïòÍ±∞ÎÇò,
      // Î¨¥Ïñ∏Í∞ÄÍ∞Ä ÎåÄÍ∏∞ Ï§ëÏù¥ÎùºÎ©¥ ÌÉÄÏûÑÏïÑÏõÉ ÌõÑ Ïª§Î∞ãÏùÑ Í∏∞Îã§Î¶¨Îäî Í≤ÉÏûÖÎãàÎã§.
      root.finishedWork = finishedWork;
      root.finishedLanes = lanes;
      finishConcurrentRender(root, exitStatus,
      finishedWork, lanes);
      // commitRoot()Îäî Ïó¨Í∏∞ÏÑú Ïã§ÌñâÎê©ÎãàÎã§.
    }
  }
  ensureRootIsScheduled(root);
  return getContinuationForRoot(root, originalCallbackNode);
}
```

```ts
function isRenderConsistentWithExternalStores(finishedWork: Fiber): boolean {
  // Î†åÎçîÎêú Ìä∏Î¶¨ÏóêÏÑú Ïô∏Î∂Ä Ïä§ÌÜ†Ïñ¥ ÏùΩÍ∏∞Î•º Í≤ÄÏÉâÌïòÍ≥†, ÎèôÏãú Ïù¥Î≤§Ìä∏ÏóêÏÑú Ïä§ÌÜ†Ïñ¥Í∞Ä Î≥ÄÏ°∞ÎêòÏóàÎäîÏßÄ ÌôïÏù∏Ìï©ÎãàÎã§.
  // Ïû¨Í∑Ä ÎåÄÏã† Î∞òÎ≥µ Î£®ÌîÑÎ•º ÏÇ¨Ïö©ÌïòÏó¨ ÏùºÏ∞ç Ï¢ÖÎ£åÌï† Ïàò ÏûàÎèÑÎ°ù Ìï©ÎãàÎã§.
  let node: Fiber = finishedWork;
  while (true) {
    if (node.flags & StoreConsistency) {
      const updateQueue: FunctionComponentUpdateQueue | null =
        (node.updateQueue: any);
      if (updateQueue !== null) {
        const checks = updateQueue.stores;
        if (checks !== null) {
          for (let i = 0; i < checks.length; i++) {
            const check = checks[i];
            const getSnapshot = check.getSnapshot;
            const renderedValue = check.value;
            try {
              if (!is(getSnapshot(), renderedValue)) {
                // Î∂àÏùºÏπòÌïòÎäî Ïä§ÌÜ†Ïñ¥Î•º Î∞úÍ≤¨ÌñàÏäµÎãàÎã§.
                return false;
              }
            } catch (error) {
              // `getSnapshot`Ïù¥ Ïò§Î•òÎ•º Î∞úÏÉùÏãúÌÇ§Î©¥ `false`Î•º Î∞òÌôòÌï©ÎãàÎã§.
              // Ïù¥Î°ú Ïù∏Ìï¥ Îã§Ïãú Î†åÎçîÎßÅÏù¥ ÏòàÏïΩÎêòÍ≥†, Î†åÎçîÎßÅ Ï§ëÏóê Ïò§Î•òÍ∞Ä Îã§Ïãú Î∞úÏÉùÌï©ÎãàÎã§.
              return false;
            }
          }
        }
      }
    }
    const child = node.child;
    if (node.subtreeFlags & StoreConsistency && child !== null) {
      child.return = node;
      node = child;
      continue;
    }
    if (node === finishedWork) {
      return true;
    }
    while (node.sibling === null) {
      if (node.return === null || node.return === finishedWork) {
        return true;
      }
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
  // FlowÎäî Ïù¥Í≤ÉÏù¥ ÎèÑÎã¨Ìï† Ïàò ÏóÜÎäî ÏΩîÎìúÎùºÎäî Í≤ÉÏùÑ ÏïåÏßÄ Î™ªÌïòÏßÄÎßå, eslintÎäî Ïïå Ïàò ÏûàÏäµÎãàÎã§.
  // eslint-disable-next-line no-unreachable
  return true;
}

```

### 3. ÏöîÏïΩ

Ïù¥Ï†ú `useSyncExternalStore()`Í∞Ä ÎÇ¥Î∂ÄÏ†ÅÏúºÎ°ú Ïñ¥ÎñªÍ≤å ÏûëÎèôÌïòÎäîÏßÄ Ïù¥Ìï¥ÌñàÏúºÎØÄÎ°ú, Ï£ºÎ°ú Îëê Í∞ÄÏßÄ Î¨∏Ï†úÎ•º Ìï¥Í≤∞ÌïòÎäî Í≤ÉÏùÑ Ïïå Ïàò ÏûàÏäµÎãàÎã§.

1. **ÎèôÏãú Î™®ÎìúÏóêÏÑúÏùò Ï∞¢Ïñ¥Ïßê(Tearing):** `useSyncExternalStore()`Îäî Î†åÎçîÎßÅÏù¥ ÏôÑÎ£åÎêú ÌõÑ Ïª§Î∞ãÏù¥ ÏãúÏûëÎêòÍ∏∞ Ï†ÑÏóê ÏùºÍ¥ÄÏÑ± Í≤ÄÏÇ¨Î•º ÏòàÏïΩÌïòÏó¨ Ïù¥ Î¨∏Ï†úÎ•º Ìï¥Í≤∞Ìï©ÎãàÎã§. ÎèôÍ∏∞ Î™®ÎìúÏóêÏÑú Îã§Ïãú Î†åÎçîÎßÅÏù¥ Í∞ïÏ†úÎêòÏñ¥ Î∂àÏùºÏπòÌïú Îç∞Ïù¥ÌÑ∞Í∞Ä UIÏóê ÌëúÏãúÎêòÏßÄ ÏïäÍ≤å Ìï©ÎãàÎã§.

2. **Í∞êÏßÄÎêòÏßÄ ÏïäÏùÄ Ïô∏Î∂Ä Ïä§ÌÜ†Ïñ¥ Î≥ÄÍ≤Ω:** `useSyncExternalStore()`Îäî ÏàòÎèô Ìö®Í≥ºÎ•º ÌÜµÌï¥ Î≥ÄÍ≤Ω ÏÇ¨Ìï≠Ïù¥ ÏûàÎäîÏßÄ ÌôïÏù∏ÌïòÍ≥†, Î≥ÄÍ≤Ω ÏÇ¨Ìï≠Ïù¥ ÏûàÏúºÎ©¥ ÎèôÍ∏∞ Î™®ÎìúÏóêÏÑú Îã§Ïãú Î†åÎçîÎßÅÏùÑ ÏòàÏïΩÌï©ÎãàÎã§. Ïù¥Îäî Ïª§Î∞ã ÌõÑÏóê Î∞úÏÉùÌïòÎØÄÎ°ú ÏÇ¨Ïö©ÏûêÎäî UI ÍπúÎπ°ÏûÑÏùÑ Î≥º Ïàò ÏûàÏäµÎãàÎã§.
